import type { Component, Editor, ProjectData, TraitProperties } from 'grapesjs';
import type { AstroComponentProp, ComponentRegistryEntry } from 'studiocms/componentRegistry/types';
import { parse } from './utils.js';

/**
 * Generates an HTML string representation of the main component within the editor,
 * including its styles. The styles are adjusted to replace all occurrences of 'body'
 * with 'div' to ensure proper scoping.
 *
 * @param editor - The editor instance from which to extract the main page and component.
 * @returns A promise that resolves to a string containing the HTML and scoped styles.
 */
export const generateHTML = async (editor: Editor): Promise<string> => {
	const page = editor.Pages.getMain();
	const component = page.getMainComponent();
	const htmlData = component.toHTML({ tag: 'div' });
	const styles = editor.getCss({ component })?.replaceAll('body', 'div');
	const html = `${htmlData}${styles ? `<style>${styles}</style>` : ''}`;
	return html;
};

/**
 * Adds an 'inline' storage provider to the given editor instance.
 *
 * This storage provider allows loading and storing project data directly within the editor context.
 * When storing, it serializes the provided data along with the current editor HTML content
 * (generated by `generateHTML(editor)`) into the specified `pageContent` element's `innerText`.
 *
 * @param editor - The editor instance to which the storage provider will be added.
 * @param opts - Options for storage:
 *   - `projectData`: The project data to be loaded.
 *   - `pageContent`: The HTML element where serialized data will be stored.
 */
export const inlineStorage = (
	editor: Editor,
	opts: { projectData: ProjectData; pageContent: HTMLElement }
) => {
	editor.Storage.add('inline', {
		async load() {
			return opts.projectData;
		},
		async store(data) {
			opts.pageContent.innerText = JSON.stringify({
				...data,
				__STUDIOCMS_HTML: await generateHTML(editor),
			});
		},
	});
};

/**
 * Reduces an array of `TraitProperties` into an accumulator object, mapping trait names to their values.
 *
 * - If the trait type is `'number'`, the value is coerced to a number.
 * - If the trait value is an empty string, the default value is used.
 * - Traits without a name are skipped.
 *
 * @param acc - The accumulator object that collects trait name-value pairs.
 * @param trait - The trait to process and add to the accumulator.
 * @returns The updated accumulator with the trait's name and resolved value.
 */

// biome-ignore lint/suspicious/noExplicitAny: this is the expected type for the accumulator
export function traitReducer(acc: Record<string, any>, trait: TraitProperties) {
	if (!trait.name) return acc;

	let value: string | number = trait.default;

	if (trait.type === 'number') {
		value = Number(trait.value !== '' ? trait.value : trait.default);
	} else {
		value = trait.value !== '' ? trait.value : trait.default;
	}

	acc[trait.name] = value;
	return acc;
}

/**
 * Extracts and aggregates trait properties from a given component model.
 *
 * @param model - The component model containing traits to extract.
 * @returns An object containing the aggregated trait properties.
 */
export const getTraitData = (model: Component) => {
	const traitData: TraitProperties[] = model.traits.toJSON();
	// biome-ignore lint/suspicious/noExplicitAny: this is the expected type for the accumulator
	const propsData = traitData.reduce(traitReducer, {} as Record<string, any>);
	return propsData;
};

/**
 * Generates an HTML string representing the slot data for a given component model.
 *
 * Iterates through the child components of the provided model, converts each child to HTML,
 * and wraps it with its respective tag name. The resulting HTML strings are concatenated
 * and returned as a single string.
 *
 * @param model - The component model whose children will be processed.
 * @returns A string containing the HTML representation of the model's child components,
 *          or an empty string if there are no children.
 */
export const getSlotData = (model: Component) => {
	const children = model.components().toArray();
	let slotData = '';

	if (children.length > 0) {
		slotData = children
			.map((child) => {
				const childHtml = child.toHTML({ tag: 'div' });
				return `<${child.tagName}>${childHtml}</${child.tagName}>`;
			})
			.join('');
	}

	return slotData;
};

/**
 * Returns the appropriate input type for a given trait type.
 *
 * @param type - The trait type to filter (e.g., "number", "string", etc.).
 * @returns The corresponding input type as a string. Returns "number" if the type is "number", otherwise returns "text".
 */
export const traitTypeFilter = (type: string) => {
	switch (type) {
		case 'number':
			return 'number';
		default:
			return 'text';
	}
};

/**
 * Maps an `AstroComponentProp` to a new object with filtered type, name, and default value.
 *
 * @param prop - The Astro component property to map.
 * @returns An object containing:
 *  - `type`: The filtered type of the property.
 *  - `name`: The name of the property.
 *  - `default`: The default value of the property.
 */
export const traitMapFn = (prop: AstroComponentProp) => ({
	type: traitTypeFilter(prop.type),
	name: prop.name,
	default: prop.defaultValue,
});

/**
 * Builds a partial request configuration for a given component model.
 *
 * @param model - The component model to build the request from.
 * @returns A `RequestInit` object configured for a POST request with the component's data as JSON.
 */
export const partialRequestBuilder = (model: Component): RequestInit => {
	return {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			componentKey: model.tagName,
			props: getTraitData(model),
			slot: getSlotData(model),
		}),
	};
};

/**
 * Retrieves and parses editor-related data elements from the DOM.
 *
 * @param document - The DOM Document object to query for elements.
 * @param selectors - An object containing CSS selectors for the container and page content elements.
 * @param selectors.container - CSS selector for the GrapesJS container element.
 * @param selectors.pageContent - CSS selector for the page content textarea element.
 * @returns An object containing references to the page content element, the parsed component registry, and the parsed project data.
 * @throws Will throw an error if the container or page content elements are not found in the DOM.
 */
export function getEditorElmData(
	document: Document,
	selectors: {
		container: string;
		pageContent: string;
	}
) {
	const container = document.querySelector<HTMLDivElement>(selectors.container) as HTMLDivElement;

	if (!container) {
		throw new Error('GrapesJS container not found. Ensure the HTML structure is correct.');
	}

	const pageContent = document.querySelector<HTMLTextAreaElement>(
		selectors.pageContent
	) as HTMLTextAreaElement;

	if (!pageContent) {
		throw new Error('Page content textarea not found. Ensure the HTML structure is correct.');
	}

	const componentRegistry = parse<ComponentRegistryEntry[]>(
		container.dataset.componentRegistry || '{}'
	);

	const fallbackPages = {
		pages: [{ name: 'page' }],
	};

	const projectData = parse<ProjectData>(pageContent.innerText || JSON.stringify(fallbackPages));

	return {
		astroComponentsOpts: { componentRegistry },
		inlineStorageOpts: {
			pageContent,
			projectData,
		}
	};
}
