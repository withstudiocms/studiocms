import type { Component, Editor, ProjectData, TraitProperties } from 'grapesjs';

/**
 * Generates an HTML string representation of the main component within the editor,
 * including its styles. The styles are adjusted to replace all occurrences of 'body'
 * with 'div' to ensure proper scoping.
 *
 * @param editor - The editor instance from which to extract the main page and component.
 * @returns A promise that resolves to a string containing the HTML and scoped styles.
 */
export const generateHTML = async (editor: Editor): Promise<string> => {
	const page = editor.Pages.getMain();
	const component = page.getMainComponent();
	const htmlData = component.toHTML({ tag: 'div' });
	const styles = editor.getCss({ component })?.replaceAll('body', 'div');
	const html = `${htmlData}${styles ? `<style>${styles}</style>` : ''}`;
	return html;
};

/**
 * Adds an 'inline' storage provider to the given editor instance.
 *
 * This storage provider allows loading and storing project data directly within the editor context.
 * When storing, it serializes the provided data along with the current editor HTML content
 * (generated by `generateHTML(editor)`) into the specified `pageContent` element's `innerText`.
 *
 * @param editor - The editor instance to which the storage provider will be added.
 * @param opts - Options for storage:
 *   - `projectData`: The project data to be loaded.
 *   - `pageContent`: The HTML element where serialized data will be stored.
 */
export const inlineStorage = (
	editor: Editor,
	opts: { projectData: ProjectData; pageContent: HTMLElement }
) => {
	editor.Storage.add('inline', {
		async load() {
			return opts.projectData;
		},
		async store(data) {
			opts.pageContent.innerText = JSON.stringify({
				...data,
				__STUDIOCMS_HTML: await generateHTML(editor),
			});
		},
	});
};

/**
 * Reduces an array of `TraitProperties` into an accumulator object, mapping trait names to their values.
 *
 * - If the trait type is `'number'`, the value is coerced to a number.
 * - If the trait value is an empty string, the default value is used.
 * - Traits without a name are skipped.
 *
 * @param acc - The accumulator object that collects trait name-value pairs.
 * @param trait - The trait to process and add to the accumulator.
 * @returns The updated accumulator with the trait's name and resolved value.
 */

// biome-ignore lint/suspicious/noExplicitAny: this is the expected type for the accumulator
export function traitReducer(acc: Record<string, any>, trait: TraitProperties) {
	if (!trait.name) return acc;

	let value: string | number = trait.default;

	if (trait.type === 'number') {
		value = Number(trait.value !== '' ? trait.value : trait.default);
	} else {
		value = trait.value !== '' ? trait.value : trait.default;
	}

	acc[trait.name] = value;
	return acc;
}

/**
 * Extracts and aggregates trait properties from a given component model.
 *
 * @param model - The component model containing traits to extract.
 * @returns An object containing the aggregated trait properties.
 */
export const getTraitData = (model: Component) => {
	const traitData: TraitProperties[] = model.traits.toJSON();
	// biome-ignore lint/suspicious/noExplicitAny: this is the expected type for the accumulator
	const propsData = traitData.reduce(traitReducer, {} as Record<string, any>);
	return propsData;
};

/**
 * Generates an HTML string representing the slot data for a given component model.
 *
 * Iterates through the child components of the provided model, converts each child to HTML,
 * and wraps it with its respective tag name. The resulting HTML strings are concatenated
 * and returned as a single string.
 *
 * @param model - The component model whose children will be processed.
 * @returns A string containing the HTML representation of the model's child components,
 *          or an empty string if there are no children.
 */
export const getSlotData = (model: Component) => {
	const children = model.components().toArray();
	let slotData = '';

	if (children.length > 0) {
		slotData = children
			.map((child) => {
				const childHtml = child.toHTML({ tag: 'div' });
				return `<${child.tagName}>${childHtml}</${child.tagName}>`;
			})
			.join('');
	}

	return slotData;
};

/**
 * Returns the appropriate input type for a given trait type.
 *
 * @param type - The trait type to filter (e.g., "number", "string", etc.).
 * @returns The corresponding input type as a string. Returns "number" if the type is "number", otherwise returns "text".
 */
export const traitTypeFilter = (type: string) => {
	switch (type) {
		case 'number':
			return 'number';
		default:
			return 'text';
	}
};
