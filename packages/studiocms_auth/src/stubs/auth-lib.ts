import DTSBuilder from '@matthiesenxyz/astrodtsbuilder';
import { createResolver } from 'astro-integration-kit';

const { resolve } = createResolver(import.meta.url);

const authLib = DTSBuilder();

authLib.addSingleLineNote(
	'This file is generated by StudioCMS and should not be modified manually.'
);

authLib.addModule('studiocms:auth/lib/encription', {
	namedExports: [
		{
			name: 'encrypt',
			typeDef: `typeof import('${resolve('../lib/encryption.ts')}').encrypt`,
			multiLineDescription: [
				'Encrypts the given data using AES-128-GCM encryption.',
				'',
				'@param data - The data to be encrypted as a Uint8Array.',
				'@returns The encrypted data as a Uint8Array, which includes the initialization vector (IV), the encrypted content, and the authentication tag.',
			],
		},
		{
			name: 'encryptString',
			typeDef: `typeof import('${resolve('../lib/encryption.ts')}').encryptString`,
			multiLineDescription: [
				'Encrypts a given string and returns the encrypted data as a Uint8Array.',
				'',
				'@param data - The string to be encrypted.',
				'@returns The encrypted data as a Uint8Array.',
			],
		},
		{
			name: 'decrypt',
			typeDef: `typeof import('${resolve('../lib/encryption.ts')}').decrypt`,
			multiLineDescription: [
				'Decrypts the given encrypted data using AES-128-GCM.',
				'',
				'@param encrypted - The encrypted data as a Uint8Array. The data must be at least 33 bytes long.',
				'@returns The decrypted data as a Uint8Array.',
				'@throws Will throw an error if the encrypted data is less than 33 bytes.',
			],
		},
		{
			name: 'decryptToString',
			typeDef: `typeof import('${resolve('../lib/encryption.ts')}').decryptToString`,
			multiLineDescription: [
				'Decrypts the given Uint8Array data and returns the result as a string.',
				'',
				'@param data - The encrypted data as a Uint8Array.',
				'@returns The decrypted data as a string.',
			],
		},
	],
});

authLib.addModule('studiocms:auth/lib/password', {
	namedExports: [
		{
			name: 'hashPassword',
			typeDef: `typeof import('${resolve('../lib/password.ts')}').hashPassword`,
			multiLineDescription: [
				'Hashes a plain text password using bcrypt.',
				'',
				'@param password - The plain text password to hash.',
				'@returns A promise that resolves to the hashed password.',
			],
		},
		{
			name: 'verifyPasswordHash',
			typeDef: `typeof import('${resolve('../lib/password.ts')}').verifyPasswordHash`,
			multiLineDescription: [
				'Verifies if the provided password matches the hashed password.',
				'',
				'@param hash - The hashed password to compare against.',
				'@param password - The plain text password to verify.',
				'@returns A promise that resolves to a boolean indicating whether the password matches the hash.',
			],
		},
		{
			name: 'verifyPasswordStrength',
			typeDef: `typeof import('${resolve('../lib/password.ts')}').verifyPasswordStrength`,
			multiLineDescription: [
				'Verifies the strength of a given password.',
				'',
				'The password must meet the following criteria:',
				'- Be between 6 and 255 characters in length.',
				'- Not be a known unsafe password.',
				'- Not be found in the pwned password database.',
				'',
				'@param password - The password to verify.',
				'@returns A promise that resolves to `true` if the password is strong/secure enough, otherwise `false`.',
			],
		},
	],
});

authLib.addUnformattedString(`declare module 'studiocms:auth/lib/rate-limit' {
	/**
	 * Represents a token bucket that refills tokens at a specified interval.
	 * Used to control access to resources by limiting the number of tokens
	 * that can be consumed over time.
	 *
	 * @template _Key - The type of key used to identify individual token buckets.
	 */
	export class RefillingTokenBucket<_Key> {
		/**
		 * The maximum number of tokens that the bucket can hold.
		 * @type {number}
		 */
		public max: number;
		/**
		 * The interval in seconds at which tokens are refilled.
		 * @type {number}
		 */
		public refillIntervalSeconds: number;
		/**
		 * Initializes a new instance of the RefillingTokenBucket class.
		 *
		 * @param {number} max - The maximum number of tokens the bucket can hold.
		 * @param {number} refillIntervalSeconds - The refill interval in seconds.
		 */
		constructor(max: number, refillIntervalSeconds: number);
		/**
		 * A map storing individual token buckets associated with specific keys.
		 * @private
		 */
		private storage;
		/**
		 * Checks if there are enough tokens available in the bucket for the specified key and cost.
		 *
		 * @param {_Key} key - The key associated with the token bucket.
		 * @param {number} cost - The number of tokens required.
		 * @returns {boolean} - Returns 'true' if there are enough tokens; otherwise, 'false'.
		 */
		public check(key: _Key, cost: number): boolean;
		/**
		 * Consumes tokens from the bucket for the specified key and cost.
		 *
		 * @param {_Key} key - The key associated with the token bucket.
		 * @param {number} cost - The number of tokens to consume.
		 * @returns {boolean} - Returns 'true' if tokens were successfully consumed; otherwise, 'false'.
		 */
		public consume(key: _Key, cost: number): boolean;
	}

	/**
	 * Represents a throttler that limits the frequency of actions performed with a specified key.
	 * Uses incremental timeouts to delay repeated actions.
	 *
	 * @template _Key - The type of key used to identify throttling counters.
	 */
	export class Throttler<_Key> {
		/**
		 * Array of timeout durations (in seconds) for each consecutive attempt.
		 * @type {number[]}
		 */
		public timeoutSeconds: number[];
		/**
		 * A map storing individual throttling counters associated with specific keys.
		 * @private
		 */
		private storage;
		/**
		 * Initializes a new instance of the Throttler class.
		 *
		 * @param {number[]} timeoutSeconds - Array of timeout durations in seconds for each consecutive attempt.
		 */
		constructor(timeoutSeconds: number[]);
		/**
		 * Attempts to consume an action for the specified key.
		 *
		 * @param {_Key} key - The key associated with the throttling counter.
		 * @returns {boolean} - Returns 'true' if the action is allowed; otherwise, 'false'.
		 */
		public consume(key: _Key): boolean;
		/**
		 * Resets the throttling counter for a specified key.
		 *
		 * @param {_Key} key - The key associated with the throttling counter to reset.
		 */
		public reset(key: _Key): void;
	}

	/**
	 * Represents a token bucket with tokens that expire after a specified duration.
	 * Used to control access to resources with tokens that reset after expiration.
	 *
	 * @template _Key - The type of key used to identify individual token buckets.
	 */
	export class ExpiringTokenBucket<_Key> {
		/**
		 * The maximum number of tokens the bucket can hold.
		 * @type {number}
		 */
		public max: number;
		/**
		 * The duration (in seconds) after which tokens in the bucket expire.
		 * @type {number}
		 */
		public expirationSeconds: number;
		/**
		 * A map storing individual expiring token buckets associated with specific keys.
		 * @private
		 */
		constructor(max: number, expirationSeconds: number);
		/**
		 * Initializes a new instance of the ExpiringTokenBucket class.
		 *
		 * @param {number} max - The maximum number of tokens the bucket can hold.
		 * @param {number} expiresInSeconds - The duration in seconds after which tokens expire.
		 */
		private storage;
		/**
		 * Checks if there are enough tokens available in the bucket for the specified key and cost.
		 *
		 * @param {_Key} key - The key associated with the token bucket.
		 * @param {number} cost - The number of tokens required.
		 * @returns {boolean} - Returns 'true' if there are enough tokens or if the tokens have expired; otherwise, 'false'.
		 */
		public check(key: _Key, cost: number): boolean;
		/**
		 * Consumes tokens from the bucket for the specified key and cost.
		 *
		 * @param {_Key} key - The key associated with the token bucket.
		 * @param {number} cost - The number of tokens to consume.
		 * @returns {boolean} - Returns 'true' if tokens were successfully consumed; otherwise, 'false'.
		 */
		public consume(key: _Key, cost: number): boolean;
		/**
		 * Resets the token bucket for a specified key, removing all tokens.
		 *
		 * @param {_Key} key - The key associated with the token bucket to reset.
		 */
		public reset(key: _Key): void;
	}
}`);

authLib.addModule('studiocms:auth/lib/session', {
	namedExports: [
		{
			name: 'generateSessionToken',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').generateSessionToken`,
			multiLineDescription: [
				'Generates a new session token.',
				'',
				'@returns The generated session token as a string.',
			],
		},
		{
			name: 'sessionCookieName',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').sessionCookieName`,
			multiLineDescription: [
				'The name of the cookie used to store the authentication session.',
				'',
				'@constant {string}',
			],
		},
		{
			name: 'createSession',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').createSession`,
			multiLineDescription: [
				'Creates a new session for a user.',
				'',
				'@param token - The token used to create the session.',
				'@param userId - The ID of the user for whom the session is being created.',
				'@returns A promise that resolves to the created session object.',
			],
		},
		{
			name: 'validateSessionToken',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').validateSessionToken`,
			multiLineDescription: [
				'Validates a session token by checking its existence and expiration in the database.',
				'If the session is valid but close to expiration, it extends the session expiration time.',
				'If the session is expired, it deletes the session from the database.',
				'',
				'@param token - The session token to validate.',
				'@returns A promise that resolves to an object containing the session and user information. If the session is invalid or expired, both session and user will be null.',
			],
		},
		{
			name: 'invalidateSession',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').invalidateSession`,
			multiLineDescription: [
				'Invalidates a session by deleting it from the database.',
				'',
				'@param token - The session token to invalidate.',
				'@returns A promise that resolves to `true` if the session was successfully invalidated; otherwise, `false`.',
			],
		},
		{
			name: 'setSessionTokenCookie',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').setSessionTokenCookie`,
			multiLineDescription: [
				'Sets the session token cookie in the response object.',
				'',
				'@param context - The context object containing the request and response objects.',
				'@param token - The session token to set in the cookie.',
				'@param expiresAt - The expiration date and time of the session token.',
			],
		},
		{
			name: 'deleteSessionTokenCookie',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').deleteSessionTokenCookie`,
			multiLineDescription: [
				'Deletes the session token cookie from the response object.',
				'',
				'@param context - The context object containing the request and response objects.',
			],
		},
		{
			name: 'setOAuthSessionTokenCookie',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').setOAuthSessionTokenCookie`,
			multiLineDescription: [
				'Sets the OAuth session token cookie in the response object.',
				'',
				'@param context - The context object containing the request and response objects.',
				'@param key - The name of the cookie to set.',
				'@param expiresAt - The expiration date and time of the session token.',
			],
		},
		{
			name: 'makeExpirationDate',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').makeExpirationDate`,
			multiLineDescription: [
				'Generates a new expiration date for a session.',
				'',
				'@returns The expiration date calculated by adding the session expiration time to the current date and time.',
			],
		},
		{
			name: 'sessionExpTime',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').sessionExpTime`,
			multiLineDescription: [
				'The session expiration time in milliseconds.',
				'This value represents 14 days.',
			],
		},
		{
			name: 'createUserSession',
			typeDef: `typeof import('${resolve('../lib/session.ts')}').createUserSession`,
			multiLineDescription: [
				'Creates a new user session.',
				'',
				'@param userId - The ID of the user to create the session for.',
				'@param context - The context object containing the request and response objects.',
				'@returns A promise that resolves to the created session object.',
			],
		},
	],
});

authLib.addModule('studiocms:auth/lib/types', {
	typeExports: [
		{
			name: 'UserTable',
			typeDef: `import('${resolve('../lib/types.ts')}').UserTable`,
			multiLineDescription: [
				'Represents a user in the database.',
				'',
				'@interface UserTable',
				'@property {string} id - The unique identifier for the user.',
				"@property {string | null} url - The URL of the user's profile.",
				'@property {string} name - The name of the user.',
				'@property {string | null} email - The email address of the user.',
				"@property {string | null} avatar - The URL of the user's avatar.",
				'@property {string} username - The username of the user.',
				'@property {string | null} password - The hashed password of the user.',
				'@property {Date | null} updatedAt - The date and time when the user was last updated.',
				'@property {Date | null} createdAt - The date and time when the user was created.',
			],
		},
		{
			name: 'SessionTable',
			typeDef: `import('${resolve('../lib/types.ts')}').SessionTable`,
			multiLineDescription: [
				'Represents a session in the database.',
				'',
				'@interface SessionTable',
				'@property {string} id - The unique identifier for the session.',
				'@property {string} userId - The unique identifier for the user associated with the session.',
				'@property {Date} expiresAt - The expiration date and time of the session.',
			],
		},
		{
			name: 'OAuthAccountsTable',
			typeDef: `import('${resolve('../lib/types.ts')}').OAuthAccountsTable`,
			multiLineDescription: [
				'Represents a table of OAuth accounts.',
				'',
				'@interface OAuthAccountsTable',
				'@property {string} provider - The name of the OAuth provider (e.g., Google, Facebook).',
				'@property {string} providerUserId - The unique identifier for the user provided by the OAuth provider.',
				'@property {string} userId - The unique identifier for the user within the application.',
			],
		},
		{
			name: 'PermissionsTable',
			typeDef: `import('${resolve('../lib/types.ts')}').PermissionsTable`,
			multiLineDescription: [
				'Interface representing a table of user permissions.',
				'',
				'@interface PermissionsTable',
				'@property {string} user - The username of the individual.',
				'@property {string} rank - The rank or role assigned to the user.',
			],
		},
		{
			name: 'UserSessionData',
			typeDef: `import('${resolve('../lib/types.ts')}').UserSessionData`,
			multiLineDescription: [
				'Represents the session data for a user.',
				'',
				'@property {boolean} isLoggedIn - Indicates whether the user is logged in.',
				'@property {UserTable | null} user - The user data, or null if no user is logged in.',
				"@property {'owner' | 'admin' | 'editor' | 'visitor' | 'unknown'} permissionLevel - The permission level of the user.",
			],
		},
		{
			name: 'UserSession',
			typeDef: `import('${resolve('../lib/types.ts')}').UserSession`,
			multiLineDescription: [
				'Represents a user session which includes user information and session details.',
				'',
				'@property {UserTable} user - The user data.',
				'@property {SessionTable} session - The session data.',
			],
		},
		{
			name: 'SessionValidationResult',
			typeDef: `import('${resolve('../lib/types.ts')}').SessionValidationResult`,
			multiLineDescription: [
				'Represents the result of validating a session token.',
				'',
				'This type can either be a valid `UserSession` or an object indicating an invalid session with both `session` and `user` properties set to `null`.',
			],
		},
		{
			name: 'RefillBucket',
			typeDef: `import('${resolve('../lib/types.ts')}').RefillBucket`,
			multiLineDescription: [
				'Represents an individual refillable token bucket.',
				'',
				'@interface RefillBucket',
				'@property {number} count - The current token count in the bucket.',
				'@property {number} refillAt - The time at which the bucket was last refilled.',
			],
		},
		{
			name: 'ExpiringBucket',
			typeDef: `import('${resolve('../lib/types.ts')}').ExpiringBucket`,
			multiLineDescription: [
				'Represents a bucket with an expiration mechanism.',
				'',
				'@interface ExpiringBucket',
				'@property {number} count - The current token count in the bucket.',
				'@property {number} createdAt - The timestamp when the bucket was created.',
			],
		},
		{
			name: 'ThrottlingCounter',
			typeDef: `import('${resolve('../lib/types.ts')}').ThrottlingCounter`,
			multiLineDescription: [
				'Interface representing a throttling counter.',
				'',
				'@interface ThrottlingCounter',
				'@property {number} timeout - The duration (in milliseconds) for which the throttling is applied.',
				'@property {number} updatedAt - The timestamp (in milliseconds since epoch) when the throttling counter was last updated.',
			],
		},
	],
});

authLib.addModule('studiocms:auth/lib/user', {
	namedExports: [
		{
			name: 'verifyUsernameInput',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').verifyUsernameInput`,
		},
		{
			name: 'createUserAvatar',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').createUserAvatar`,
		},
		{
			name: 'createLocalUser',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').createLocalUser`,
		},
		{
			name: 'createOAuthUser',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').createOAuthUser`,
		},
		{
			name: 'updateUserPassword',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').updateUserPassword`,
		},
		{
			name: 'getUserPasswordHash',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').getUserPasswordHash`,
		},
		{
			name: 'getUserFromEmail',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').getUserFromEmail`,
		},
		{
			name: 'getUserData',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').getUserData`,
		},
		{
			name: 'permissionRanksMap',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').permissionRanksMap`,
		},
		{
			name: 'verifyUserPermissionLevel',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').verifyUserPermissionLevel`,
		},
		{
			name: 'LinkNewOAuthCookieName',
			typeDef: `typeof import('${resolve('../lib/user.ts')}').LinkNewOAuthCookieName`,
		},
	],
});

const dtsFile = authLib.makeAstroInjectedType('auth-lib.d.ts');

export default dtsFile;
