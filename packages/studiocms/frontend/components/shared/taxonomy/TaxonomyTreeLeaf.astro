---
import { type UiLanguageKeys, useTranslations } from 'studiocms:i18n';
import { Icon } from 'studiocms:ui/components/icon';
import { type TaxonomyNodeProps } from './shared.js';

interface Props extends TaxonomyNodeProps {
	lang: UiLanguageKeys;
}

const { node, depth = 0, baseTagLink = '/', baseCategoryLink = '/', lang } = Astro.props;

const href = node.type === 'category' ? baseCategoryLink : baseTagLink;

const t = useTranslations(lang, '@studiocms/dashboard:taxonomy-tree-renderer');
---

<taxonomy-tree-leaf
    data-node-id={`taxonomy-${node.type}-${node.id}`}
    data-taxonomy-id={node.id}
    data-taxonomy-type={node.type}
    data-depth={depth}
    data-href={href}
    data-create-category-link={baseCategoryLink}
    class="tree-leaf"
    role="treeitem"
    tabindex="0"
>
    {
        node.type === "category" ? (
            <Icon
                name="heroicons:folder"
                class="leaf-icon default"
                width={20}
                height={20}
            />
            <Icon
                name="heroicons:folder-solid"
                class="leaf-icon active"
                width={20}
                height={20}
            />
        ) : (
            <Icon
                name="heroicons:tag"
                class="leaf-icon default"
                width={20}
                height={20}
            />
            <Icon
                name="heroicons:tag-solid"
                class="leaf-icon active"
                width={20}
                height={20}
            />
        )
    }
    <span class="tree-leaf-label">{node.name}</span>
</taxonomy-tree-leaf>
<div
    id={`taxonomy-${node.type}-${node.id}-context-menu`}
    class="context-menu"
    role="menu"
>
    <button class="context-menu-item" role="menuitem" data-action="edit">
        <Icon name="heroicons:pencil" width={16} height={16} />
        <span>
            <t-taxonomy-tree-leaf key={node.type === "category" ? 'edit-category' : 'edit-tag'}>
                {t(node.type === "category" ? 'edit-category' : 'edit-tag')}
            </t-taxonomy-tree-leaf>
        </span>
    </button>
    {
        node.type === "category" && (
            <button
                class="context-menu-item"
                role="menuitem"
                data-action="create-subcategory"
            >
                <Icon name="heroicons:folder-plus" width={16} height={16} />
                <span>
                    <t-taxonomy-tree-leaf key="create-sub-category">
                        {t('create-sub-category')}
                    </t-taxonomy-tree-leaf>
                </span>
            </button>
        )
    }
</div>

<script>
    import { $i18n, baseTranslation, makeTranslation } from 'studiocms:i18n/client';

    const currentPage = "@studiocms/dashboard:taxonomy-tree-renderer";

    const i18n = $i18n(currentPage, baseTranslation[currentPage]);

    if (!customElements.get("t-taxonomy-tree-renderer")) {
        customElements.define(
            "t-taxonomy-tree-renderer",
            makeTranslation(currentPage, i18n),
        );
    }
</script>

<script>
    class TaxonomyTreeLeaf extends HTMLElement {
        private href: string;
        private contextMenu: HTMLElement | null = null;
        private searchTerm: string | null = null;

        constructor() {
            super();
            this.href = this.getAttribute("data-href") || "#";
            this.searchTerm = this.getAttribute("data-search-term") || null;
        }

        connectedCallback() {
            this.setAttribute("role", "link");
            this.contextMenu = document.getElementById(
                `${this.getAttribute("data-node-id")}-context-menu`,
            );
            this.setupEventListeners();
            this.setupContextMenu();
            this.setupActiveState();
        }

        genUrl(base: string, params?: Record<string, string>) {
            const url = new URL(base, window.location.origin);

            if (params) {
                for (const [key, value] of Object.entries(params)) {
                    url.searchParams.set(key, value);
                }
            }

            return url.href;
        }

        setupActiveState() {
            // Icons live in light DOM (projected via slot)

            let hrefEdit = null;
            try {
                const url = this.genUrl(this.href, {
                    edit: this.getAttribute("data-taxonomy-id") || "",
                    mode: "edit",
                });
                hrefEdit = new URL(url).searchParams.get('edit');
            } catch {
                // Invalid URL, do nothing
            }

            const currentEdit = new URL(window.location.href).searchParams.get('edit');

            const hrefPathname = new URL(this.href, window.location.origin).pathname;
            const currentPathname = new URL(window.location.href).pathname;

            const isActive = 
                hrefEdit !== null &&
                currentEdit !== null &&
                hrefEdit === currentEdit &&
                hrefPathname === currentPathname;

            if (isActive) {
                this.setAttribute("aria-current", "page");
            } else {
                this.removeAttribute("aria-current");
            }
        }

        setupEventListeners() {
            this.addEventListener("click", () => {
                const taxonomyId = this.getAttribute("data-taxonomy-id");
                window.location.href = `${this.href}?edit=${taxonomyId}&mode=edit${this.searchTerm ? `&search=${encodeURIComponent(this.searchTerm)}` : ''}`;
            });

            this.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    const taxonomyId = this.getAttribute("data-taxonomy-id");
                    window.location.href = `${this.href}?edit=${taxonomyId}&mode=edit${this.searchTerm ? `&search=${encodeURIComponent(this.searchTerm)}` : ''}`;
                }
            });
        }

        setupContextMenu() {
            // Show context menu on right-click
            this.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                this.showContextMenu(e as MouseEvent);
            });

            // Hide context menu when clicking outside
            document.addEventListener("click", (e) => {
                if (
                    this.contextMenu &&
                    !this.contextMenu.contains(e.target as Node)
                ) {
                    this.hideContextMenu();
                }
            });

            // Handle context menu actions
            const menuItems =
                this.contextMenu?.querySelectorAll(".context-menu-item");
            menuItems?.forEach((item) => {
                item.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const action = (item as HTMLElement).getAttribute(
                        "data-action",
                    );
                    this.handleContextMenuAction(action);
                    this.hideContextMenu();
                });
            });

            // Close menu on Escape key
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    this.hideContextMenu();
                }
            });
        }

        showContextMenu(e: MouseEvent) {
            if (!this.contextMenu) return;

            this.contextMenu.style.left = `${e.clientX}px`;
            this.contextMenu.style.top = `${e.clientY}px`;
            this.contextMenu.classList.add("active");
            const containerRect = this.getBoundingClientRect();

            requestAnimationFrame(() => {
                if (!this.contextMenu) return;
                const menuRect = this.contextMenu.getBoundingClientRect();
                
                // Calculate constrained position
                let left = e.clientX;
                let top = e.clientY;

                // Check right boundary (viewport and container)
                const maxRight = Math.min(window.innerWidth, containerRect.right);
                if (left + menuRect.width > maxRight) {
                    left = Math.max(containerRect.left, maxRight - menuRect.width);
                }

                // Check bottom boundary (viewport and container)
                const maxBottom = Math.min(window.innerHeight, containerRect.bottom);
                if (top + menuRect.height > maxBottom) {
                    top = Math.max(containerRect.top, maxBottom - menuRect.height);
                }

                // Ensure menu doesn't go outside left/top of container
                left = Math.max(containerRect.left, left);
                top = Math.max(containerRect.top, top);

                this.contextMenu.style.left = `${left}px`;
                this.contextMenu.style.top = `${top}px`;
            });
        }

        hideContextMenu() {
            this.contextMenu?.classList.remove("active");
        }

        handleContextMenuAction(action: string | null) {
            if (!action) return;

            const taxonomyId = this.getAttribute("data-taxonomy-id");

            switch (action) {
                case "edit":
                    window.location.href = this.genUrl(this.href, {
                        edit: taxonomyId || "",
                        mode: "edit",
                        ...(this.searchTerm ? { search: this.searchTerm } : {}),
                    });
                    break;
                case "create-subcategory":
                    const createCategoryLink = this.getAttribute(
                        "data-create-category-link",
                    );
                    if (createCategoryLink) {
                        window.location.href = this.genUrl(createCategoryLink, {
                            parent: taxonomyId || "",
                            mode: "create",
                            ...(this.searchTerm ? { search: this.searchTerm } : {}),
                        });
                    }
                    break;
            }
        }
    }

    if (!customElements.get("taxonomy-tree-leaf")) {
        customElements.define("taxonomy-tree-leaf", TaxonomyTreeLeaf);
    }
</script>
