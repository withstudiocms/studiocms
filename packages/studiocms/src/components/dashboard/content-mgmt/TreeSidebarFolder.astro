---
import { Icon } from 'studiocms:ui/components';
import type { HeroIconName } from '@studiocms/ui/components/Icon/iconType.js';
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'a'> {
	/**
	 * ONLY USE OUTLINED ICONS! Shit will break otherwise
	 */
	icon: HeroIconName;
	name: string;
	href: string;
}

const { icon, name, class: className, ...props } = Astro.props;

const activeIcon = `${icon}-solid`;

const compId = crypto.randomUUID();
---

<tree-sidebar-folder
  id={compId}
  class:list={["inner-sidebar-link", className]}
  {...props}
>
  <Icon
    name={icon}
    id="not-selected-icon"
    class="sidebar-link-icon not-selected"
    width={24}
    height={24}
  />
  <Icon
    name={activeIcon as HeroIconName}
    id="selected-icon"
    class="sidebar-link-icon selected"
    width={24}
    height={24}
  />
  <span class="sidebar-link-text">
    {name}
  </span>
</tree-sidebar-folder>
<slot />

<script>
  class TreeSidebarFolder extends HTMLElement {
    href: string;

    constructor() {
      super();
      this.attachShadow({ mode: "open" });
      this.href = this.getAttribute("href") || "#";
    }

    connectedCallback() {
      this.render();
      // Basic link semantics and keyboard focus
      this.setAttribute("role", "link");
      if (!this.hasAttribute("tabindex")) this.tabIndex = 0;
      this.setSidebarActiveState();
      this.setupEventListeners();
    }

    render() {
      if (!this.shadowRoot) return;
      // Avoid duplicating the slot on reconnect
      if (this.shadowRoot.childNodes.length === 0) {
        const slot = document.createElement("slot");
        this.shadowRoot.appendChild(slot);
      }
    }

    setSidebarActiveState() {
      // Query icons from Light DOM since they're projected through the slot
      const notSelectedIcon = this.querySelector("#not-selected-icon");
      const selectedIcon = this.querySelector("#selected-icon");

      let hrefEdit = null;
      try {
        hrefEdit = new URL(
          this.getAttribute("href") || this.href || "#",
          window.location.origin,
        ).searchParams.get("folder");
      } catch {}
      const currentEdit = new URL(window.location.href).searchParams.get(
        "folder",
      );

      const isActive =
        hrefEdit !== null && currentEdit !== null && hrefEdit === currentEdit;

      this.classList.toggle("active", !!isActive);
      if (notSelectedIcon)
        (notSelectedIcon as HTMLElement).style.display = isActive
          ? "none"
          : "block";
      if (selectedIcon)
        (selectedIcon as HTMLElement).style.display = isActive
          ? "block"
          : "none";
      if (isActive) {
        this.setAttribute('aria-current', 'page');
      } else {
        this.removeAttribute('aria-current');
      }
    }

    setupEventListeners() {
      this.addEventListener('click', (event) => {
        const e = event as MouseEvent;
        const url = new URL(this.href, window.location.origin);
        const isHttp = url.protocol === 'http:' || url.protocol === 'https:';
        const target = this.getAttribute('target');
        const openInNewTab = target === '_blank' || e.ctrlKey || e.metaKey || e.button === 1;

        if (!isHttp) return;

        if (openInNewTab) {
          // Preserve default middle-click behavior if this were a native link
          e.preventDefault();
          window.open(url.href, '_blank');
          return;
        }

        // Primary (left) click same-tab navigation
        if (e.button === 0) {
          e.preventDefault();
          window.location.href = url.href;
        }
      });
      this.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.click();
        }
      });
    }
  }

  if (!customElements.get("tree-sidebar-folder")) {
    customElements.define("tree-sidebar-folder", TreeSidebarFolder);
  }
</script>
