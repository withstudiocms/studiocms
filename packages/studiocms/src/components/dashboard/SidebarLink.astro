---
import { Icon } from 'studiocms:ui/components/icon';
import type { AvailableIcons } from 'studiocms:ui/icons';
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'a'> {
	/**
	 * ONLY USE OUTLINED ICONS! Shit will break otherwise
	 */
	icon: AvailableIcons;
	href: string;
}

const { icon, class: className, ...props } = Astro.props;

const activeIcon = (icon.endsWith('-solid') ? icon : `${icon}-solid`) as AvailableIcons;

const compId = crypto.randomUUID();
---

<sidebar-link
  id={compId}
  class:list={["sidebar-link", className]}
  data-dashboard-index={Astro.locals.StudioCMS.routeMap.mainLinks
    .dashboardIndex}
  {...props}
>
  <Icon
    name={icon}
    id="not-selected-icon"
    class="sidebar-link-icon not-selected"
    width={24}
    height={24}
  />
  <Icon
    name={activeIcon}
    id="selected-icon"
    class="sidebar-link-icon selected"
    width={24}
    height={24}
  />
  <span class="sidebar-link-text">
    <slot />
  </span>
</sidebar-link>

<script>
  class SidebarLink extends HTMLElement {
    href: string;
    dashboardIndex: string;

    constructor() {
      super();
      this.attachShadow({ mode: "open" });
      this.href = this.getAttribute("href") || "#";
      this.dashboardIndex = this.getAttribute("data-dashboard-index") || "";
    }

    connectedCallback() {
      this.render();
      // Link semantics and keyboard access
      this.setAttribute("role", "link");
      if (!this.hasAttribute("tabindex")) this.tabIndex = 0;
      this.setSidebarActiveState();
      this.setupEventListeners();
    }

    render() {
      if (!this.shadowRoot) return;
      if (this.shadowRoot.childNodes.length === 0) {
        const slot = document.createElement("slot");
        this.shadowRoot.appendChild(slot);
      }
    }

    setupEventListeners() {
      this.addEventListener('click', (event) => {
        const e = event as MouseEvent;
        const url = new URL(this.href, window.location.origin);
        const isHttp = url.protocol === 'http:' || url.protocol === 'https:';
        const target = this.getAttribute('target');
        const openInNewTab = target === '_blank' || e.ctrlKey || e.metaKey || e.button === 1;

        if (!isHttp) return;

        if (openInNewTab) {
          // Preserve default middle-click behavior if this were a native link
          e.preventDefault();
          window.open(url.href, '_blank');
          return;
        }

        // Primary (left) click same-tab navigation
        if (e.button === 0) {
          e.preventDefault();
          window.location.href = url.href;
        }
      });
      this.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.click();
        }
      });
    }

    setSidebarActiveState() {
      // Light DOM icons projected through the slot
      const notSelectedIcon = this.querySelector(".not-selected");
      const selectedIcon = this.querySelector(".selected");

      const normalize = (p: string) => p.replace(/\/+$/, "") || "/";
      const windowLocation = normalize(window.location.pathname);
      let elemPath = normalize(
        new URL(this.href, window.location.origin).pathname,
      );
      const webDashboardIndex = normalize(
        new URL(window.location.origin + this.dashboardIndex).pathname,
      );

      // Match exact or sub-path segments only (avoid false positives like "/user" vs "/user-settings")
      const startsWithSeg = (path: string, base: string) => {
        if (base === "/") return path === "/";
        return path === base || path.startsWith(base + "/");
      };

      // Determine if the link is active based on the current URL and the href
      // The dashboard index is a special case where it should match only the root (i.e., "/dashboard")
      // but should not match sub-paths like "/dashboard/settings" unless that is the href.
      let isActive = false;

      if (
        windowLocation === webDashboardIndex &&
        elemPath === webDashboardIndex
      ) {
        isActive = true; // Exact match for the dashboard index
      }

      if (
        windowLocation !== webDashboardIndex &&
        elemPath !== webDashboardIndex
      ) {
        // Check if the current path starts with the href path
        isActive = startsWithSeg(windowLocation, elemPath);
      }

      this.classList.toggle("active", isActive);
      if (notSelectedIcon)
        (notSelectedIcon as HTMLElement).style.display = isActive
          ? "none"
          : "block";
      if (selectedIcon)
        (selectedIcon as HTMLElement).style.display = isActive
          ? "block"
          : "none";
      if (isActive) {
        this.setAttribute('aria-current', 'page');
      } else {
        this.removeAttribute('aria-current');
      }
    }

    static get observedAttributes() {
      return ["href"];
    }
    attributeChangedCallback(name: string, _oldValue: any, newValue: string) {
      if (name === "href") {
        this.href = newValue || "#";
        this.setSidebarActiveState();
      }
    }
  }

  if (!customElements.get("sidebar-link")) {
    customElements.define("sidebar-link", SidebarLink);
  }
</script>
